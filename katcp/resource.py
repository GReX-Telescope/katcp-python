"""A high-level abstract interface to KATCP clients, sensors and requests."""

import abc

import collections

from katcp import Message
from katcp.sampling import SampleStrategy


def normalize_strategy_parameters(params):
    """Normalize strategy parameters to be a list of strings.

    Parameters
    ----------
    params : (space-delimited) string or number or sequence of strings/numbers
        Parameters expected by :class:`SampleStrategy` object, in various forms

    Returns
    -------
    params : list of strings
        Strategy parameters as a list of strings

    """
    if not params:
        return []
    def fixup_numbers(val):
        try:
            # See if it is a number
            return str(float(val))
        except ValueError:
            # ok, it is not a number we know of, perhaps a string
            return str(val)
    if isinstance(params, basestring):
        params = params.split(' ')
    elif not isinstance(params, collections.Iterable):
        params = (params,)
    return [fixup_numbers(p) for p in params]


def escape_name(name):
    """Escape sensor and request names to be valid Python identifiers."""
    return name.replace(".","_").replace("-","_")


class KATCPResource(object):
    """Base class to serve as the definition of the KATCPResource API

    A class `C` implementing the KATCPResource API should register itself using
    KATCPResource.register(C), or subclass KATCPResource directly. A complication involved
    with subclassing is that all the abstract properties must be implemented as
    properties; normal instance attributes cannot be used.

    Attributes
    ----------

    Apart from the abstract properties described below

    TODO Describe how hierarchies are implemented. Also all other descriptions here so
    that the sphinx doc can be autogenerated from here.
    """
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def address(self):
        """Address of the device that this request is connected to

        type: tuple(host, port) None, where host is a string and port an integer.

        If this KATCPResource is not associated with a specific KATCP device (e.g. it is
        only a top-level container for a hierarchy of KATCP resources), it should be None.
        """

    @abc.abstractproperty
    def name(self):
        """Name of this KATCP Resource (str)"""

    @abc.abstractproperty
    def req(self):
        """Attribute root/container for all request KATRequest instances

        Each KATCP request that is exposed for a KATCP device should have a corresponding
        KATRequest object just that katresource.req.request_name(arg1, arg2, ...)
        corresponds to sending a '?request-name arg1 arg2 ...' message to the KATCP device
        and waiting for the associated inform-reply and reply messages.

        For a KATCPResource object that exposes a hierarchical device it can choose to
        include lower level request handlers here such that
        katresource.req.devname_request_name() maps to
        katresource.devname.req.request_name().
        """

    @abc.abstractproperty
    def sensor(self):
        """Attribute root/container for all sensor KATCPSensor instances

        Each KATCP sensor that is exposed for a KATCP device should have a corresponding
        KATCPSensor object just that katresource.sensor_name corresponds to a sensor named
        sensor[.-_]name. In other words, any '.', '-' or '_' characters in a sensor name
        is converted to '_' to form a valid Python identifier. Hopefully your device is
        not crazy enough to have multiple sensors that map to the same Python identifier.

        For a KATCPResource object that exposes a hierarchical device it can choose to
        include lower level sensor here such that katresource.sensor.devname_sensor_name
        maps to katresource.devname.sensor.sensor_name.
        """

    @abc.abstractproperty
    def parent(self):
        """Parent KATCPResource instance of subordinate members or None"""

    @abc.abstractproperty
    def children(self):
        """dict of subordinate KATCPResource instances or empty dict if none

        Maps <device_name> : KATCPResource instance.
        """

    SensorResultTuple = collections.namedtuple('SensorResultTuple', [
        'name', 'object', 'value', 'seconds', 'type', 'units'])

    def list_sensors(self, filter="", strategy=False, status="", expand_underscore=True):
        """List the sensors available on this resource matching certain criteria

        Parameters
        ----------

        filter : string, default: ""
            If specified then filter each returned sensor's name against this value. This
            is a python regexp. To ease the dichotomy between Python identifier names and
            actual sensor names, '_' is substituted with [.-_] unless `expand_underscore`
            is set to False.

            Note that the sensors of subordinate KATCPResource instances are only filtered
            on Python identifiers, e.g. a device sensor 'piano.tuning-state' will be
            represented as 'piano_tuning_state'.
        strategy : boolean, default: False
            If set to true then only list sensors for which a strategy has been set.
        status : string, default: ""
            If specified then filter each returned sensors status against this
            value. This is a Python regexp.
        expand_underscore : bool, default: True
            Expand '_' in `filter` paramter to [.-_]

        Return Value
        ------------

        array of namedtuples of matching sensors.
            namedtuple: (name, object, value, seconds, type, units). The names in
            parenthesis are also the field names of the named tuple. The `object` element
            is the KATCPSensor object corresponding to the sensor. Note that the name of
            the sensor-object may not match `name` if it originates from a subordinate
            device.
        """

class KATCPRequest(object):
    """Abstract Base class to serve as the definition of the KATCPRequest API

    Wrapper around a specific KATCP request to a given KATCP device.

    Each available KATCP request for a particular device has an associated
    :class:`KATCPRequest` object in the object hierarchy. This wrapper is mainly for
    interactive convenience. It provides the KATCP request help string as a docstring
    pretty-prints the result of the request.

    """
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def __call__(self, *args, **kwargs):
        """Execute the KATCP request described by this object.

        All positional arguments of this function are converted to KATCP string
        representations and passed on as space-separated parameters to the KATCP
        device.

        Keyword Arguments
        -----------------

        timeout : float or None
            Timeout in seconds for the request. If None, use default for the KATCPResource
            instance that it is attached to.
        mid : int or None
            Message identifier to use for the request message. If None, use either
            auto-incrementing value or no mid depending on the KATCP protocol version in
            use (mid's were only introduced with KATCP v5) and the default of the
            KATCPResource instance that it is attached to.

        Returns
        -------

        tornado future that resolves with:

        reply : :class:`KATCPReply` object
            Object wrapping the katcp messages returned by the request

        """

    @abc.abstractmethod
    def blocking(self, *args, **kwargs):
        """Blocking execution of the KATCP request described by this object

        Implementation of this method is optional. If not implemented should raise
        NotImplementedError.

        See docstring of __call__. Only difference is that it blocks and returns the
        KATCPReply object directly. Should not be called from an ioloop thread.
        """

    @abc.abstractproperty
    def name(self):
        """Name of the KATCP request"""

    @abc.abstractproperty
    def description(self):
        """Description of KATCP request as obtained from the ?help request"""

class KATCPSensor(object):
    """Abstract Base class to serve as the definition of the KATCPSensor API

    Does contain some potentially useful implementation, subclasses need to arrange
    to call _init() in their __init__()

    Attributes
    ----------

    Implementors of KATCPSensor should include the following attributes:

    name : str
        KATCP name of the sensor
    description : str
        KATCP description of the sensor
    units: str
        KATCP units of the sensor
    type: str
        KATCP type of the sensor
    """
    __metaclass__ = abc.ABCMeta

    def _init(self):
        """Subclasses must arrange to call this in their __init__()"""
        self._listeners = set()

    @property
    def strategy_params(self):
        return self._strategy_params

    @strategy_params.setter
    def strategy_params(self, val):
        self._strategy_params = normalize_strategy_parameters(val)

    def register_listener(self, listener):
        """Add a callback function that is called when sensor value is updated.

        Parameters
        ----------
        listener : function
            Callback signature: listener(update_seconds, value_seconds, status, value)
        """
        self._listeners.add(listener)

    def unregister_listener(self, listener):
        """Remove a listener callback added with register_listener().

        Parameters
        ----------
        listener : function
            Reference to the callback function that should be removed

        """
        self._listeners.discard(listener)

    @property
    def strategy(self):
        return SampleStrategy.SAMPLING_LOOKUP[self._strategy.get_sampling()]

    def clear_listeners(self):
        """Clear any registered listeners to updates from this sensor.
        """
        self._listeners = set()

_KATCPReplyTuple = collections.namedtuple('_KATCPReplyTuple', ['reply', 'informs'])

class KATCPReply(_KATCPReplyTuple):
    """namedtuple-like container for return messages of KATCP request (reply and informs).

    Parameters
    ----------
    reply : :class:`katcp.Message` object
        Reply message returned by katcp request
    informs : list of :class:`katcp.Message` objects
        List of inform messages returned by KATCP request

    Attributes
    ----------
    messages : list of :class:`katcp.Message` objects
        List of all messages returned by katcp request, reply first
    reply : :class:`katcp.Message` object
        Reply message returned by KATCP request
    informs : list of :class:`katcp.Message` objects
        List of inform messages returned by KATCP request

    The instance evaluates to nonzero (i.e. truthy) if the request succeeded.
    """

    def __repr__(self):
        """String representation for pretty-printing in IPython."""
        return '\n'.join([
            "%s%s %s" % (Message.TYPE_SYMBOLS[m.mtype], m.name, ' '.join(m.arguments))
            for m in self.messages])

    def __nonzero__(self):
        """True if katcp request succeeded (i.e. first reply argument is 'ok')."""
        return self.messages[0].reply_ok()

    @property
    def messages(self):
        return [self.reply] + self.informs

    @property
    def succeeded(self):
        """True if katcp request succeeded (i.e. first reply argument is 'ok')."""
        return bool(self)

class KATCPClientResource(KATCPResource):
    """Connects to a KATCP device resource and exposes a KATCPResource interface"""
    # TODO Implementation

class KATCPContainerResource(KATCPResource):
    """KATCPResource container for single-root 2-level KATCPResource hierarchy"""
    # TODO Implementation
